# 为什么栈比堆快

1. 栈位于一级缓存上，堆位与二级缓存上

2. 栈上面有两个专门记录地址的寄存器EBP寄存器（记录栈帧的最高地址），ESP寄存器（记录栈顶的寄存器）（栈在内存中是向下生长的）

3. 为什么操作栈中的数据比堆上的快，是因为程序在运行中，操作系统首先会为当前进程的main函数开辟一个栈帧，栈帧记录着一个未执行完的函数的现场信息

4. 这个现场信息包括着：

   ​    函数的返回地址和参数

   ​	临时变量（包括函数的非静态局部变量以及编译器自动生成的其他临时变量）

   ​	函数调用的上下文

5. 由于ESP寄存器记录着栈顶元素位置或者栈顶元素的下一个地址，而待处理的数据每次都需要进栈，因此esp总是指向待处理的数据，所以处理栈中的数据非常快，对于处理完的数据只需要弹出esp寄存器指向的数据，等待下个元素入栈

6. 首先访问堆上的数据只能通过这段连续内存的首地址才能进行访问，堆上的数据是没有两个专门寄存器来记录内存地址的，只能通过首地址偏移进行读写。																

# 关于栈与堆的安全问题：

8. 为什么处理栈上的数据是安全的呢，首先两个指针寄存器记录了这个栈帧的首尾地址，程序结束后只需要将这个esp寄存器中的值返回，然后将esp与ebp寄存器复位到操作系统分配的虚拟内存的最高地址即可（有专门的寄存器记录这个地址），这样栈空间就得到了释放；为什么堆上的数据容易造成内存泄漏呢，首先堆上的数据只能由程序员通过这个内存的首地址进行释放，（解释下为什么free首地址就能释放一整块空间呢，因为在申请的空间的末尾会多申请一个存放这个堆空间信息的结构体，free会根据指向这个堆区的指针与末尾的结构体来释放这个空间，因此在free堆空间前对首执行进行偏移是很致命的，但是编译器不会检查这种错误，运行时也大概率不会报错，但是在服务器上出错概率就会很大，因此很致命）

9. 申请堆空间涉及到系统调用，也就是进程涉及到从用户态到内核态的转变，又从内核态到用户态的转变，尽管我们在链接头文件时编译器已经预分配的一部分堆空间，但是申请空间过大或者次数过多还是涉及系统调用；

10. 堆空间上存在内存碎片，什么是内存碎片，内存碎片分为内部碎片与外部碎片。内部碎片是指分配给进程的存储空间中未被利用的部分，外部碎片指系统中无法利用的小存储块。外部碎片就涉及到了堆空间的分配原理

11. 堆分配算法：空闲链表，位图，对象池

    空闲链表： 在这个链表上的节点存储着可分配堆空间的首地址与大小，每次申请堆空间时，都会从头遍历这个链表，找到一块空间比申请空间稍大的节点，将首地址返回，同时会对这个空间进行切割，将多余的空间切除并重新挂到链表上，这个过程会产生一些被切割的小空间，如果申请的次数过多，链表上也没有可以分配的最小空间，那么就会对这些小碎片进行合并。（外碎片）

    位图：其核心思想是将整个堆分为大量的块，每个块的大小相同。当用户请求内存的时候，总是分配整数个块的数据：第一个块称为已分配区域的头，其余的称为已分配区域的主体。可以用一个整数数组来记录块的使用情况。如果堆太大，而设定的块很小，那么位图将会很大（内碎片）

    对象池：在一些特定场合，被分配对象的大小经常是固定的几个值，针对这种情况设计一个更为高效的堆分配算法：如果每一次分配的空间大小都一样，可以按照这个标准为一个单位，将整个堆空间划分为大量的小块，每次请求只需要找到一个小块就可以了。
    对象池的管理方法，可以采用空闲链表，也可以采用位图。
    
    于 <64B 的空间申请采用类似于对象池的方法，对于 >512B 自己的空间申请采用最佳适配算法；对于 64B<512B 的根据情况选择；对于 >128KB 的申请，使用 mmap 机制直接向操作系统申请空间
    
    Linux下两种对空间分配的方式
    
    1.brk()系统调用
    int brk(void end_data_seqment).*
    brk 实际就是通过设置数据段的结束地址，来扩大堆或者虽小堆空间。Glibc中有一个函数 sbrk，它的功能与 brk 类似，只是参数和返回值有差别，sbrk 以一个增量为参数，即需要增加或减少(负数)的空间大小，返回最终数据段的结束地址。
    2.mmap
    
     mmap作用是向操作系统申请一段虚拟地址空间，这块虚拟地址空间可以映射到某个文件。当它不将地址空间映射到某个文件时，我们称这块空间为**匿名空间**，也就是**堆**。
    
    

1. 当申请的空间超过128kB时，先使用brk来扩张，而内存中arena（位图，固定大小的内存池）没有最够空间分配时，使用mmap向上扩张堆空间
